"""
Base Strategy Class - Common interface for all trading strategies
Provides standardized structure for strategy implementation
"""

import logging
from abc import ABC, abstractmethod
from datetime import datetime, timedelta
from typing import Dict, Optional, Any
from dataclasses import dataclass
from enum import Enum

logger = logging.getLogger(__name__)

class StrategyStatus(Enum):
    """Strategy execution status"""
    INACTIVE = "inactive"
    ACTIVE = "active"
    PAUSED = "paused"
    ERROR = "error"


class SignalAction(Enum):
    """Trading signal actions"""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    CLOSE = "CLOSE"


@dataclass
class StrategySignal:
    """Represents a trading signal generated by a strategy"""
    symbol: str
    action: SignalAction
    price: float
    confidence: float  # 0.0 to 1.0
    timestamp: datetime
    strategy_name: str
    
    # Optional fields
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size: Optional[float] = None
    timeframe: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        if isinstance(self.action, str):
            self.action = SignalAction(self.action)
    
    def dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "symbol": self.symbol,
            "action": self.action.value,
            "price": self.price,
            "confidence": self.confidence,
            "timestamp": self.timestamp.isoformat(),
            "strategy_name": self.strategy_name,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "position_size": self.position_size,
            "timeframe": self.timeframe,
            "metadata": self.metadata or {}
        }


@dataclass
class StrategyMetrics:
    """Strategy performance metrics"""
    total_signals: int = 0
    successful_signals: int = 0
    total_trades: int = 0
    winning_trades: int = 0
    total_pnl: float = 0.0
    max_drawdown: float = 0.0
    sharpe_ratio: float = 0.0
    win_rate: float = 0.0
    avg_trade_duration: Optional[timedelta] = None
    last_updated: Optional[datetime] = None


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies
    Provides common functionality and interface
    """
    
    def __init__(self, config: Dict[str, Any], market_data_manager, name: Optional[str] = None):
        self.config = config
        self.market_data_manager = market_data_manager
        self.name = name or self.__class__.__name__
        
        # Strategy state
        self.status = StrategyStatus.INACTIVE
        self.last_signal: Optional[StrategySignal] = None
        self.last_execution: Optional[datetime] = None
        self.metrics = StrategyMetrics()
        
        # Configuration
        self.symbols = config.get("symbols", ["BTC", "ETH"])
        self.timeframe = config.get("timeframe", "1h")
        self.execution_interval = config.get("execution_interval", 60)  # seconds
        
        # Risk management
        self.max_position_size = config.get("max_position_size", 1000.0)
        self.stop_loss_pct = config.get("stop_loss_pct", 0.02)  # 2%
        self.take_profit_pct = config.get("take_profit_pct", 0.04)  # 4%
        
        # Internal state
        self._initialized = False
        self._last_data_update: Optional[datetime] = None
        self._cache: Dict[str, Any] = {}
        
        logger.info(f"ðŸ”§ Initialized strategy: {self.name}")
    
    async def initialize(self):
        """Initialize the strategy"""
        if self._initialized:
            return
        
        try:
            logger.info(f"ðŸš€ Initializing strategy: {self.name}")
            
            # Perform strategy-specific initialization
            await self._initialize_strategy()
            
            # Validate configuration
            self._validate_config()
            
            # Load historical data if needed
            await self._load_initial_data()
            
            self.status = StrategyStatus.ACTIVE
            self._initialized = True
            
            logger.info(f"âœ… Strategy {self.name} initialized successfully")
            
        except Exception as e:
            logger.error(f"âŒ Failed to initialize strategy {self.name}: {e}")
            self.status = StrategyStatus.ERROR
            raise
    
    @abstractmethod
    async def _initialize_strategy(self):
        """Strategy-specific initialization logic"""
        pass
    
    @abstractmethod
    async def generate_signal(self) -> Optional[StrategySignal]:
        """
        Generate trading signal based on current market conditions
        Returns None if no signal should be generated
        """
        pass
    
    @abstractmethod
    async def _calculate_indicators(self, symbol: str, data: Any) -> Dict[str, Any]:
        """Calculate technical indicators for the strategy"""
        pass
    
    def _validate_config(self):
        """Validate strategy configuration"""
        required_fields = ["symbols", "timeframe"]
        for field in required_fields:
            if field not in self.config:
                raise ValueError(f"Missing required configuration field: {field}")
        
        # Validate symbols
        if not isinstance(self.symbols, list) or not self.symbols:
            raise ValueError("Symbols must be a non-empty list")
        
        # Validate timeframe
        valid_timeframes = ["1m", "5m", "15m", "30m", "1h", "4h", "1d"]
        if self.timeframe not in valid_timeframes:
            raise ValueError(f"Invalid timeframe: {self.timeframe}")
    
    async def _load_initial_data(self):
        """Load initial historical data for analysis"""
        try:
            for symbol in self.symbols:
                # Load recent data for each symbol
                data = await self.market_data_manager.get_ohlcv(
                    symbol=symbol,
                    timeframe=self.timeframe,
                    limit=100  # Last 100 candles
                )
                
                if data is not None and not data.empty:
                    self._cache[f"{symbol}_data"] = data
                    logger.debug(f"ðŸ“Š Loaded {len(data)} candles for {symbol}")
                else:
                    logger.warning(f"âš ï¸ No data available for {symbol}")
                    
        except Exception as e:
            logger.error(f"âŒ Error loading initial data: {e}")
    
    async def _get_market_data(self, symbol: str, limit: int = 100) -> Optional[Any]:
        """Get market data for a symbol"""
        try:
            # Check cache first
            cache_key = f"{symbol}_data"
            cached_data = self._cache.get(cache_key)
            
            # Update data if cache is stale
            if (cached_data is None or 
                self._last_data_update is None or 
                datetime.utcnow() - self._last_data_update > timedelta(minutes=5)):
                
                data = await self.market_data_manager.get_ohlcv(
                    symbol=symbol,
                    timeframe=self.timeframe,
                    limit=limit
                )
                
                if data is not None:
                    self._cache[cache_key] = data
                    self._last_data_update = datetime.utcnow()
                    return data
                else:
                    logger.warning(f"âš ï¸ No data received for {symbol}")
                    return cached_data
            
            return cached_data
            
        except Exception as e:
            logger.error(f"âŒ Error getting market data for {symbol}: {e}")
            return None
    
    def _calculate_stop_loss(self, entry_price: float, action: SignalAction) -> float:
        """Calculate stop loss price"""
        if action == SignalAction.BUY:
            return entry_price * (1 - self.stop_loss_pct)
        elif action == SignalAction.SELL:
            return entry_price * (1 + self.stop_loss_pct)
        return entry_price
    
    def _calculate_take_profit(self, entry_price: float, action: SignalAction) -> float:
        """Calculate take profit price"""
        if action == SignalAction.BUY:
            return entry_price * (1 + self.take_profit_pct)
        elif action == SignalAction.SELL:
            return entry_price * (1 - self.take_profit_pct)
        return entry_price
    
    def _create_signal(
        self,
        symbol: str,
        action: SignalAction,
        price: float,
        confidence: float,
        metadata: Optional[Dict[str, Any]] = None
    ) -> StrategySignal:
        """Create a trading signal"""
        
        # Calculate stop loss and take profit
        stop_loss = self._calculate_stop_loss(price, action)
        take_profit = self._calculate_take_profit(price, action)
        
        signal = StrategySignal(
            symbol=symbol,
            action=action,
            price=price,
            confidence=confidence,
            timestamp=datetime.utcnow(),
            strategy_name=self.name,
            stop_loss=stop_loss,
            take_profit=take_profit,
            timeframe=self.timeframe,
            metadata=metadata or {}
        )
        
        # Update metrics
        self.metrics.total_signals += 1
        self.metrics.last_updated = datetime.utcnow()
        self.last_signal = signal
        
        return signal
    
    async def update_metrics(self, trade_result: Dict[str, Any]):
        """Update strategy metrics based on trade results"""
        self.metrics.total_trades += 1
        
        if trade_result.get("pnl", 0) > 0:
            self.metrics.winning_trades += 1
            self.metrics.successful_signals += 1
        
        self.metrics.total_pnl += trade_result.get("pnl", 0)
        self.metrics.win_rate = self.metrics.winning_trades / self.metrics.total_trades
        self.metrics.last_updated = datetime.utcnow()
        
        # Update max drawdown if applicable
        current_drawdown = trade_result.get("drawdown", 0)
        if current_drawdown > self.metrics.max_drawdown:
            self.metrics.max_drawdown = current_drawdown
    
    def get_status(self) -> Dict[str, Any]:
        """Get strategy status and metrics"""
        return {
            "name": self.name,
            "status": self.status.value,
            "symbols": self.symbols,
            "timeframe": self.timeframe,
            "last_signal": self.last_signal.dict() if self.last_signal else None,
            "last_execution": self.last_execution.isoformat() if self.last_execution else None,
            "metrics": {
                "total_signals": self.metrics.total_signals,
                "successful_signals": self.metrics.successful_signals,
                "total_trades": self.metrics.total_trades,
                "winning_trades": self.metrics.winning_trades,
                "win_rate": self.metrics.win_rate,
                "total_pnl": self.metrics.total_pnl,
                "max_drawdown": self.metrics.max_drawdown,
                "sharpe_ratio": self.metrics.sharpe_ratio
            },
            "config": self.config
        }
    
    async def pause(self):
        """Pause strategy execution"""
        self.status = StrategyStatus.PAUSED
        logger.info(f"â¸ï¸ Strategy {self.name} paused")
    
    async def resume(self):
        """Resume strategy execution"""
        if self.status == StrategyStatus.PAUSED:
            self.status = StrategyStatus.ACTIVE
            logger.info(f"â–¶ï¸ Strategy {self.name} resumed")
    
    async def stop(self):
        """Stop strategy execution"""
        self.status = StrategyStatus.INACTIVE
        logger.info(f"ðŸ›‘ Strategy {self.name} stopped")
    
    def is_active(self) -> bool:
        """Check if strategy is active"""
        return self.status == StrategyStatus.ACTIVE
    
    def __str__(self) -> str:
        return f"{self.name}({self.status.value})"
    
    def __repr__(self) -> str:
        return f"<{self.__class__.__name__}: {self.name} - {self.status.value}>"


class TechnicalIndicatorMixin:
    """Mixin class providing common technical indicators"""
    
    @staticmethod
    def calculate_sma(data, period: int):
        """Calculate Simple Moving Average"""
        if hasattr(data, 'rolling'):
            return data.rolling(window=period).mean()
        return None
    
    @staticmethod
    def calculate_ema(data, period: int):
        """Calculate Exponential Moving Average"""
        if hasattr(data, 'ewm'):
            return data.ewm(span=period).mean()
        return None
    
    @staticmethod
    def calculate_rsi(data, period: int = 14):
        """Calculate Relative Strength Index"""
        try:
            delta = data.diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
            rs = gain / loss
            rsi = 100 - (100 / (1 + rs))
            return rsi
        except Exception:
            return None
    
    @staticmethod
    def calculate_bollinger_bands(data, period: int = 20, std_dev: float = 2):
        """Calculate Bollinger Bands"""
        try:
            sma = data.rolling(window=period).mean()
            std = data.rolling(window=period).std()
            upper_band = sma + (std * std_dev)
            lower_band = sma - (std * std_dev)
            return upper_band, sma, lower_band
        except Exception:
            return None, None, None
    
    @staticmethod
    def calculate_vwap(high, low, close, volume):
        """Calculate Volume Weighted Average Price"""
        try:
            typical_price = (high + low + close) / 3
            vwap = (typical_price * volume).cumsum() / volume.cumsum()
            return vwap
        except Exception:
            return None 